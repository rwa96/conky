-- params for battery usage diagram
params = {
    -- top left {x, y}
    pos={0,0},
    width=400,
    height=300,
    color="#FFF",
    font="mono",
    -- font used for x and y axis
    font_size_small=12,
    font_size_large=18,
    title="Battery Usage",
    -- number of marks on y axis
    y_steps=4,
    -- number of marks on x_axis
    x_steps=4,
    -- maximum number of recorded datapoints
    max_x_points=24,
    -- min time difference between points
    delta_t=1,
    -- file to cache data points
    cache_file="/tmp/conky_battery.cache"
}

-- header of cache file
local header_desc = [[-- This file is automatically generated by conky
return {
]]

-- loads cache file, extends it by new value and stores it again
--
-- @param new_val table (new data entry {x, y})
-- @param val_num_max number (maximum number of data entries)
-- @param delta_t number (minimum delay between cache file updates)
-- @param file_path string (path for cache file, preferably in tmp folder)
-- @returns table (all cached points including new one)
function history(new_val, val_num_max, delta_t, file_path)
    local f = loadfile(file_path)
    local hist_data = {}
    if f ~= nil then hist_data = f() end

    if table.getn(hist_data) == 0 or new_val[1] - hist_data[table.getn(hist_data)][1] > delta_t then
        table.insert(hist_data, new_val)
    end

    while table.getn(hist_data) > val_num_max do
        table.remove(hist_data, 1)
    end

    do
        local start = math.max(1, table.getn(hist_data) - val_num_max)
        local f = assert(io.open(file_path, "w+"))
        f:write(header_desc)
        for i = 1,table.getn(hist_data) do
            f:write(string.format(
                "\t{%d, %d},\n",
                hist_data[i][1],
                hist_data[i][2]
            ))
        end
        f:write("}")
        f:close()
    end

    return hist_data
end


function conky_main()
    if conky_window == nil then
        return
    end

    local points = history(
        {os.time(), tonumber(conky_parse("${battery_percent}"))},
        params.max_x_points, params.delta_t, params.cache_file
    )

    local min_x = points[1][1]
    local max_x = points[table.getn(points)][1]

    local rgb = {Utils.hex2rgb(params.color)}
    local text_w = 3 * params.font_size_small
    local grid_width = params.width - 8 - text_w
    local grid_height = params.height - 10 - params.font_size_large - params.font_size_small
    local grid_start_x = params.pos[1] + 3
    local grid_start_y = params.pos[2] + 8 + params.font_size_large

    local px_per_y_unit = grid_height / 100
    local px_per_x_unit = grid_width / math.max(1, (max_x - min_x))


    local drv = {}

    -- actual graph
    do
        local grad_m = grid_height / grid_width
        local grad_x = (grid_width/grad_m - grid_height) / (grad_m + 1/grad_m)
        local grad_y = grad_x * grad_m

        local multiline = {t="multiline"}
        for i, p in ipairs(points) do
            local x = (p[1] - min_x) * px_per_x_unit
            local y = -p[2] * px_per_y_unit
            if y == 0 then y = -grid_height end -- y should never be zero (display max value in case of error)
            table.insert(multiline, {x, y})
        end
        table.insert(multiline, {
            grid_width,
            -(points[table.getn(points)][2] * px_per_y_unit)
        })
        table.insert(multiline, {grid_width, 0})
        table.insert(drv, Polygon:new{
            pos={grid_start_x, grid_start_y+grid_height},
            color={Utils.create_linear(
                {grid_width, -grid_height}, {grad_x, grad_y},
                {0, rgb[1], rgb[2], rgb[3], .6},
                {1, rgb[1], rgb[2], rgb[3], 0}
            )},
            fill_type="fill",
            components={multiline},
            close_path=true
        })
    end

    -- histogram outline
    table.insert(drv, Rectangle:new{
        pos={grid_start_x, grid_start_y},
        width=grid_width,
        height=grid_height,
        line_width=1,
        color={Utils.create_rgba(rgb[1], rgb[2], rgb[3], 1)}
    })

    -- y axis marks
    do
        local offset = grid_height / params.y_steps
        local dy = 100 / params.y_steps
        for y_step = 0,params.y_steps do
            table.insert(drv, Line:new{
                pos={grid_start_x+grid_width-4, grid_start_y+grid_height - (y_step*offset +1)},
                end_pos={6, 0},
                line_width=2,
                color={Utils.create_rgba(rgb[1], rgb[2], rgb[3], 1)}
            })
            table.insert(drv, Text:new{
                pos={grid_start_x+grid_width+4, grid_start_y+grid_height - y_step*offset},
                text = string.format("%d%%", dy*y_step),
                color={Utils.create_rgba(rgb[1], rgb[2], rgb[3], 1)},
                font = params.font,
                font_size = params.font_size_small,
            })
        end
    end

    -- x axis marks
    do
        local offset = grid_width / params.x_steps
        local dx = math.max(1, (max_x - min_x)) / params.x_steps
        for x_step = 0,params.x_steps-1 do
            table.insert(drv, Line:new{
                pos={grid_start_x+1+x_step*offset, grid_start_y+grid_height - 4},
                end_pos={0, 6},
                line_width=2,
                color={Utils.create_rgba(rgb[1], rgb[2], rgb[3], 1)}
            })
            table.insert(drv, Text:new{
                pos={grid_start_x+1+x_step*offset, grid_start_y+grid_height + 4 + params.font_size_small},
                text = os.date("%I:%M", min_x + dx*x_step),
                color={Utils.create_rgba(rgb[1], rgb[2], rgb[3], 1)},
                font = params.font,
                font_size = params.font_size_small,
            })
        end
    end

    -- title
    table.insert(drv, Text:new{
        pos={grid_start_x+grid_width/2, grid_start_y-4},
        text = params.title,
        color={Utils.create_rgba(rgb[1], rgb[2], rgb[3], 1)},
        hoz="center",
        font = params.font,
        font_size = params.font_size_large
    })

    local cnv = Canvas:new(conky_window, drv)
    cnv:display()
    cnv:destroy()
end
